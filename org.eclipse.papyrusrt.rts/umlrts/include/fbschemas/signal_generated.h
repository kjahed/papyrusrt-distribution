// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SIGNAL_FBSCHEMA_H_
#define FLATBUFFERS_GENERATED_SIGNAL_FBSCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace FBSchema {

struct Signal;

struct Signal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL = 4,
    VT_NAME = 6,
    VT_SOURCESLOT = 8,
    VT_DESTINATIONSLOT = 10,
    VT_SOURCEPORT = 12,
    VT_DESTINATIONPORT = 14,
    VT_ISDESTINATIONINTERNAL = 16,
    VT_ISSOURCEINTERNAL = 18,
    VT_PAYLOADSIZE = 20,
    VT_PAYLOAD = 22
  };
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *sourceSlot() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCESLOT);
  }
  const flatbuffers::String *destinationSlot() const {
    return GetPointer<const flatbuffers::String *>(VT_DESTINATIONSLOT);
  }
  int32_t sourcePort() const {
    return GetField<int32_t>(VT_SOURCEPORT, 0);
  }
  int32_t destinationPort() const {
    return GetField<int32_t>(VT_DESTINATIONPORT, 0);
  }
  bool isDestinationInternal() const {
    return GetField<uint8_t>(VT_ISDESTINATIONINTERNAL, 0) != 0;
  }
  bool isSourceInternal() const {
    return GetField<uint8_t>(VT_ISSOURCEINTERNAL, 0) != 0;
  }
  int32_t payloadSize() const {
    return GetField<int32_t>(VT_PAYLOADSIZE, 0);
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SOURCESLOT) &&
           verifier.VerifyString(sourceSlot()) &&
           VerifyOffset(verifier, VT_DESTINATIONSLOT) &&
           verifier.VerifyString(destinationSlot()) &&
           VerifyField<int32_t>(verifier, VT_SOURCEPORT) &&
           VerifyField<int32_t>(verifier, VT_DESTINATIONPORT) &&
           VerifyField<uint8_t>(verifier, VT_ISDESTINATIONINTERNAL) &&
           VerifyField<uint8_t>(verifier, VT_ISSOURCEINTERNAL) &&
           VerifyField<int32_t>(verifier, VT_PAYLOADSIZE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct SignalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(Signal::VT_PROTOCOL, protocol);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Signal::VT_NAME, name);
  }
  void add_sourceSlot(flatbuffers::Offset<flatbuffers::String> sourceSlot) {
    fbb_.AddOffset(Signal::VT_SOURCESLOT, sourceSlot);
  }
  void add_destinationSlot(flatbuffers::Offset<flatbuffers::String> destinationSlot) {
    fbb_.AddOffset(Signal::VT_DESTINATIONSLOT, destinationSlot);
  }
  void add_sourcePort(int32_t sourcePort) {
    fbb_.AddElement<int32_t>(Signal::VT_SOURCEPORT, sourcePort, 0);
  }
  void add_destinationPort(int32_t destinationPort) {
    fbb_.AddElement<int32_t>(Signal::VT_DESTINATIONPORT, destinationPort, 0);
  }
  void add_isDestinationInternal(bool isDestinationInternal) {
    fbb_.AddElement<uint8_t>(Signal::VT_ISDESTINATIONINTERNAL, static_cast<uint8_t>(isDestinationInternal), 0);
  }
  void add_isSourceInternal(bool isSourceInternal) {
    fbb_.AddElement<uint8_t>(Signal::VT_ISSOURCEINTERNAL, static_cast<uint8_t>(isSourceInternal), 0);
  }
  void add_payloadSize(int32_t payloadSize) {
    fbb_.AddElement<int32_t>(Signal::VT_PAYLOADSIZE, payloadSize, 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Signal::VT_PAYLOAD, payload);
  }
  explicit SignalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalBuilder &operator=(const SignalBuilder &);
  flatbuffers::Offset<Signal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Signal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Signal> CreateSignal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> sourceSlot = 0,
    flatbuffers::Offset<flatbuffers::String> destinationSlot = 0,
    int32_t sourcePort = 0,
    int32_t destinationPort = 0,
    bool isDestinationInternal = false,
    bool isSourceInternal = false,
    int32_t payloadSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  SignalBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payloadSize(payloadSize);
  builder_.add_destinationPort(destinationPort);
  builder_.add_sourcePort(sourcePort);
  builder_.add_destinationSlot(destinationSlot);
  builder_.add_sourceSlot(sourceSlot);
  builder_.add_name(name);
  builder_.add_protocol(protocol);
  builder_.add_isSourceInternal(isSourceInternal);
  builder_.add_isDestinationInternal(isDestinationInternal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Signal> CreateSignalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *protocol = nullptr,
    const char *name = nullptr,
    const char *sourceSlot = nullptr,
    const char *destinationSlot = nullptr,
    int32_t sourcePort = 0,
    int32_t destinationPort = 0,
    bool isDestinationInternal = false,
    bool isSourceInternal = false,
    int32_t payloadSize = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto sourceSlot__ = sourceSlot ? _fbb.CreateString(sourceSlot) : 0;
  auto destinationSlot__ = destinationSlot ? _fbb.CreateString(destinationSlot) : 0;
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return FBSchema::CreateSignal(
      _fbb,
      protocol__,
      name__,
      sourceSlot__,
      destinationSlot__,
      sourcePort,
      destinationPort,
      isDestinationInternal,
      isSourceInternal,
      payloadSize,
      payload__);
}

inline const FBSchema::Signal *GetSignal(const void *buf) {
  return flatbuffers::GetRoot<FBSchema::Signal>(buf);
}

inline const FBSchema::Signal *GetSizePrefixedSignal(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FBSchema::Signal>(buf);
}

inline bool VerifySignalBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FBSchema::Signal>(nullptr);
}

inline bool VerifySizePrefixedSignalBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FBSchema::Signal>(nullptr);
}

inline void FinishSignalBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBSchema::Signal> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSignalBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBSchema::Signal> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FBSchema

#endif  // FLATBUFFERS_GENERATED_SIGNAL_FBSCHEMA_H_
